# Generated by Django 5.2 on 2025-12-24 08:27

import datetime
from django.db import migrations, models


def convert_datetime_to_date_time(apps, schema_editor):
    """Convert existing DateTimeField values to DateField and TimeField."""
    Season = apps.get_model('predictions', 'Season')
    db_alias = schema_editor.connection.alias
    connection = schema_editor.connection
    
    # Check if we're using SQLite
    is_sqlite = connection.vendor == 'sqlite'
    
    for season in Season.objects.using(db_alias).all():
        # At this point, start_date and end_date are still DateTimeField
        # We need to extract the date and time parts, but keep the datetime for now
        # The AlterField operation will handle converting datetime to date
        
        updates = {}
        time_updates = {}
        
        # Extract time from datetime fields and set time fields
        if season.start_date:
            if isinstance(season.start_date, datetime.datetime):
                time_updates['start_time'] = season.start_date.time()
                # Keep the datetime as-is - AlterField will extract the date part
                # Don't update start_date here, let AlterField handle it
            else:
                # Already a date (shouldn't happen at this migration stage, but handle it)
                time_updates['start_time'] = datetime.time(0, 0, 0)
        else:
            # If start_date is None, set default time
            time_updates['start_time'] = datetime.time(0, 0, 0)
        
        if season.end_date:
            if isinstance(season.end_date, datetime.datetime):
                time_updates['end_time'] = season.end_date.time()
                # Keep the datetime as-is - AlterField will extract the date part
                # Don't update end_date here, let AlterField handle it
            else:
                # Already a date (shouldn't happen at this migration stage, but handle it)
                time_updates['end_time'] = datetime.time(23, 59, 59)
        else:
            # If end_date is None, set default time
            time_updates['end_time'] = datetime.time(23, 59, 59)
        
        # Only update time fields - leave date fields alone
        # The AlterField operation will automatically extract the date from the datetime
        if time_updates:
            Season.objects.using(db_alias).filter(pk=season.pk).update(**time_updates)


def reverse_datetime_conversion(apps, schema_editor):
    """Reverse conversion - combine date and time back to datetime."""
    Season = apps.get_model('predictions', 'Season')
    db_alias = schema_editor.connection.alias
    from django.utils import timezone
    for season in Season.objects.using(db_alias).all():
        # Combine date and time back to datetime
        updates = {}
        if hasattr(season, 'start_date') and hasattr(season, 'start_time') and season.start_date and season.start_time:
            start_dt = datetime.datetime.combine(season.start_date, season.start_time)
            if timezone.is_naive(start_dt):
                start_dt = timezone.make_aware(start_dt)
            updates['start_date'] = start_dt
        if hasattr(season, 'end_date') and hasattr(season, 'end_time') and season.end_date and season.end_time:
            end_dt = datetime.datetime.combine(season.end_date, season.end_time)
            if timezone.is_naive(end_dt):
                end_dt = timezone.make_aware(end_dt)
            updates['end_date'] = end_dt
        if updates:
            Season.objects.using(db_alias).filter(pk=season.pk).update(**updates)


class Migration(migrations.Migration):

    dependencies = [
        ('predictions', '0026_alter_season_end_date_alter_season_start_date'),
    ]

    operations = [
        # First, add the time fields as nullable
        migrations.AddField(
            model_name='season',
            name='end_time',
            field=models.TimeField(null=True, help_text='Time when the season ends (defaults to 23:59:59)'),
        ),
        migrations.AddField(
            model_name='season',
            name='start_time',
            field=models.TimeField(null=True, help_text='Time when the season starts (defaults to 00:00:00)'),
        ),
        # Convert existing datetime data to date and time
        migrations.RunPython(convert_datetime_to_date_time, reverse_datetime_conversion),
        # Now make time fields non-nullable with defaults
        migrations.AlterField(
            model_name='season',
            name='end_time',
            field=models.TimeField(default=datetime.time(23, 59, 59), help_text='Time when the season ends (defaults to 23:59:59)'),
        ),
        migrations.AlterField(
            model_name='season',
            name='start_time',
            field=models.TimeField(default=datetime.time(0, 0), help_text='Time when the season starts (defaults to 00:00:00)'),
        ),
        # Change date fields from DateTimeField to DateField
        migrations.AlterField(
            model_name='season',
            name='end_date',
            field=models.DateField(help_text='Date when the season ends'),
        ),
        migrations.AlterField(
            model_name='season',
            name='start_date',
            field=models.DateField(help_text='Date when the season starts'),
        ),
        # Update model options and indexes
        migrations.AlterModelOptions(
            name='season',
            options={'ordering': ['-start_date', '-start_time', 'name'], 'verbose_name': 'Season', 'verbose_name_plural': 'Seasons'},
        ),
        migrations.RemoveIndex(
            model_name='season',
            name='predictions_start_d_63d112_idx',
        ),
        migrations.AddIndex(
            model_name='season',
            index=models.Index(fields=['start_date', 'start_time', 'end_date', 'end_time'], name='predictions_start_d_03930c_idx'),
        ),
    ]
