# Generated by Django 5.2 on 2025-11-29 07:10

from django.db import migrations, models


def backfill_lock_forfeited_at(apps, schema_editor):
    """Backfill lock_forfeited_at for existing forfeited locks from event outcomes."""
    UserTip = apps.get_model('predictions', 'UserTip')
    EventOutcome = apps.get_model('predictions', 'EventOutcome')
    
    # Find all forfeited locks without lock_forfeited_at
    forfeited_tips = UserTip.objects.filter(
        lock_status='forfeited',
        lock_forfeited_at__isnull=True
    ).select_related('prediction_event')
    
    updated_count = 0
    for tip in forfeited_tips:
        try:
            # Try to get the event outcome's resolved_at
            outcome = EventOutcome.objects.get(prediction_event=tip.prediction_event)
            if outcome.resolved_at:
                tip.lock_forfeited_at = outcome.resolved_at
                tip.save(update_fields=['lock_forfeited_at'])
                updated_count += 1
        except EventOutcome.DoesNotExist:
            # If no outcome exists, leave lock_forfeited_at as None
            # This is fine - the lock will be handled by normal expiration logic
            pass


def reverse_backfill_lock_forfeited_at(apps, schema_editor):
    """Reverse migration - clear lock_forfeited_at (not really needed, but for completeness)."""
    # No-op: we don't need to reverse this data migration
    pass


class Migration(migrations.Migration):

    dependencies = [
        ('predictions', '0016_teilnahmebedingungensection'),
    ]

    operations = [
        migrations.AddField(
            model_name='usertip',
            name='lock_forfeited_at',
            field=models.DateTimeField(blank=True, help_text='Timestamp when the lock was forfeited (used for season-aware restoration).', null=True),
        ),
        migrations.RunPython(
            backfill_lock_forfeited_at,
            reverse_backfill_lock_forfeited_at,
        ),
    ]
